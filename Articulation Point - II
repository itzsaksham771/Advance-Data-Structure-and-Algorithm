import java.util.*;
class Solution { 
    static int time;
    static ArrayList<Integer> articulationPoints(int V, int[][] edges) { 
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for(int i = 0; i < V; i++) adj.add(new ArrayList<>());
        for(int[] e : edges){ 
            int u = e[0], v = e[1];
            adj.get(u).add(v);
            adj.get(v).add(u);
        }
        int[] disc = new int[V];
        int[] low = new int[V];
        boolean[] visited = new boolean[V];
        boolean[] isAP = new boolean[V];
        time = 0;
        for(int i = 0; i < V; i++){ 
            if(!visited[i]){ 
                dfs(i, -1, adj, visited, disc, low, isAP);
            }
        }
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i = 0; i < V; i++){ 
            if(isAP[i]) ans.add(i);
        }
        if(ans.isEmpty()) ans.add(-1);
        return ans;
    }
    static void dfs(int u, int parent, ArrayList<ArrayList<Integer>> adj,
    boolean[] visited, int[] disc, int[] low, boolean[] isAP){ 
visited[u] = true;
disc[u] = low[u] = ++time;
int childCount = 0;
for(int v : adj.get(u)){ 
    if(v == parent) continue;
    if(!visited[v]){ 
        childCount++;
        dfs(v, u, adj, visited, disc, low, isAP);
        low[u] = Math.min(low[u], low[v]);
        if(parent != -1 && low[v] >= disc[u]){ 
            isAP[u] = true;
        }
    }
    else{ 
        low[u] = Math.min(low[u], disc[v]);
    }
}
if(parent == -1 && childCount > 1){ 
    isAP[u] = true;
}
}
}
